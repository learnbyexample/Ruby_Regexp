<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Exercise Solutions - Ruby Regexp</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Example based guide to mastering Ruby Regexp"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=why-is-it-needed.html><strong aria-hidden=true>2.</strong> Why is it needed?</a><li class="chapter-item expanded"><a href=regexp-introduction.html><strong aria-hidden=true>3.</strong> Regexp introduction</a><li class="chapter-item expanded"><a href=anchors.html><strong aria-hidden=true>4.</strong> Anchors</a><li class="chapter-item expanded"><a href=alternation-and-grouping.html><strong aria-hidden=true>5.</strong> Alternation and Grouping</a><li class="chapter-item expanded"><a href=escaping-metacharacters.html><strong aria-hidden=true>6.</strong> Escaping metacharacters</a><li class="chapter-item expanded"><a href=dot-metacharacter-and-quantifiers.html><strong aria-hidden=true>7.</strong> Dot metacharacter and Quantifiers</a><li class="chapter-item expanded"><a href=interlude-tools-for-debugging-and-visualization.html><strong aria-hidden=true>8.</strong> Interlude: Tools for debugging and visualization</a><li class="chapter-item expanded"><a href=working-with-matched-portions.html><strong aria-hidden=true>9.</strong> Working with matched portions</a><li class="chapter-item expanded"><a href=character-class.html><strong aria-hidden=true>10.</strong> Character class</a><li class="chapter-item expanded"><a href=groupings-and-backreferences.html><strong aria-hidden=true>11.</strong> Groupings and backreferences</a><li class="chapter-item expanded"><a href=interlude-common-tasks.html><strong aria-hidden=true>12.</strong> Interlude: Common tasks</a><li class="chapter-item expanded"><a href=lookarounds.html><strong aria-hidden=true>13.</strong> Lookarounds</a><li class="chapter-item expanded"><a href=modifiers.html><strong aria-hidden=true>14.</strong> Modifiers</a><li class="chapter-item expanded"><a href=unicode.html><strong aria-hidden=true>15.</strong> Unicode</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>16.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html class=active><strong aria-hidden=true>17.</strong> Exercise Solutions</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Ruby Regexp</h1><div class=right-buttons><a href=https://github.com/learnbyexample/Ruby_Regexp title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search name=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1><a class=header href=#exercise-solutions id=exercise-solutions>Exercise solutions</a></h1><blockquote><p><img src=images/info.svg alt=info> Refer to <a href=https://github.com/learnbyexample/Ruby_Regexp/tree/master/exercises>exercises folder</a> for input files required to solve the exercises.</blockquote><br><h1><a class=header href=#regexp-introduction id=regexp-introduction>Regexp introduction</a></h1><p><strong>a)</strong> Check whether the given strings contain <code>0xB0</code>. Display a boolean result as shown below.<pre><code class=language-ruby>>> line1 = 'start address: 0xA0, func1 address: 0xC0'
>> line2 = 'end address: 0xFF, func2 address: 0xB0'

>> line1.match?(/0xB0/)
=> false
>> line2.match?(/0xB0/)
=> true
</code></pre><p><strong>b)</strong> For the given input file, print all lines containing the string <code>two</code>.<pre><code class=language-ruby># note that expected output shown here is wrapped to fit pdf width
>> filename = 'programming_quotes.txt'

>> word = /two/

>> puts File.foreach(filename).grep(word)
"Some people, when confronted with a problem, think - I know, I'll use regular
expressions. Now they have two problems" by Jamie Zawinski
"So much complexity in software comes from trying to make one thing do two
things" by Ryan Singer
</code></pre><p><strong>c)</strong> Replace all occurrences of <code>5</code> with <code>five</code> for the given string.<pre><code class=language-ruby>>> ip = 'They ate 5 apples and 5 oranges'

>> ip.gsub(/5/, 'five')
=> "They ate five apples and five oranges"
</code></pre><p><strong>d)</strong> Replace first occurrence of <code>5</code> with <code>five</code> for the given string.<pre><code class=language-ruby>>> ip = 'They ate 5 apples and 5 oranges'

>> ip.sub(/5/, 'five')
=> "They ate five apples and 5 oranges"
</code></pre><p><strong>e)</strong> For the given array, filter all elements that do <em>not</em> contain <code>e</code>.<pre><code class=language-ruby>>> items = %w[goal new user sit eat dinner]

>> items.grep_v(/e/)
=> ["goal", "sit"]
</code></pre><p><strong>f)</strong> Replace all occurrences of <code>note</code> irrespective of case with <code>X</code>.<pre><code class=language-ruby>>> ip = 'This note should not be NoTeD'

>> ip.gsub(/note/i, 'X')
=> "This X should not be XD"
</code></pre><p><strong>g)</strong> For the given input string, print all lines NOT containing the string <code>2</code><pre><code class=language-ruby>'> purchases = %q{items qty
'> apple 24
'> mango 50
'> guava 42
'> onion 31
>> water 10}

>> num = /2/

>> puts purchases.each_line.grep_v(num)
items qty
mango 50
onion 31
water 10
</code></pre><p><strong>h)</strong> For the given array, filter all elements that contains either <code>a</code> or <code>w</code>.<pre><code class=language-ruby>>> items = %w[goal new user sit eat dinner]

>> items.filter { |e| e.match?(/a/) || e.match?(/w/) }
=> ["goal", "new", "eat"]
</code></pre><p><strong>i)</strong> For the given array, filter all elements that contains both <code>e</code> and <code>n</code>.<pre><code class=language-ruby>>> items = %w[goal new user sit eat dinner]

>> items.filter { |e| e.match?(/e/) && e.match?(/n/) }
=> ["new", "dinner"]
</code></pre><p><strong>j)</strong> For the given string, replace <code>0xA0</code> with <code>0x7F</code> and <code>0xC0</code> with <code>0x1F</code>.<pre><code class=language-ruby>>> ip = 'start address: 0xA0, func1 address: 0xC0'

>> ip.gsub(/0xA0/, '0x7F').gsub(/0xC0/, '0x1F')
=> "start address: 0x7F, func1 address: 0x1F"
</code></pre><p><strong>k)</strong> Find the starting index of the first occurrence of <code>is</code> for the given input string.<pre><code class=language-ruby>>> ip = 'match this after the history lesson'

>> ip =~ /is/
=> 8
</code></pre><br><h1><a class=header href=#anchors id=anchors>Anchors</a></h1><p><strong>a)</strong> Check if the given strings start with <code>be</code>.<pre><code class=language-ruby>>> line1 = 'be nice'
>> line2 = '"best!"'
>> line3 = 'better?'
>> line4 = 'oh no\nbear spotted'

>> pat = /\Abe/

>> pat.match?(line1)
=> true
>> pat.match?(line2)
=> false
>> pat.match?(line3)
=> true
>> pat.match?(line4)
=> false
</code></pre><p><strong>b)</strong> For the given input string, change only whole word <code>red</code> to <code>brown</code><pre><code class=language-ruby>>> words = 'bred red spread credible'

>> words.gsub(/\bred\b/, 'brown')
=> "bred brown spread credible"
</code></pre><p><strong>c)</strong> For the given input array, filter all elements containing <code>42</code> surrounded by word characters.<pre><code class=language-ruby>>> items = ['hi42bye', 'nice1423', 'bad42', 'cool_42a', 'fake4b']

>> items.grep(/\B42\B/)
=> ["hi42bye", "nice1423", "cool_42a"]
</code></pre><p><strong>d)</strong> For the given input array, filter all elements that start with <code>den</code> or end with <code>ly</code><pre><code class=language-ruby>>> items = ['lovely', "1\ndentist", '2 lonely', 'eden', "fly\n", 'dent']

>> items.filter { |e| e.match?(/\Aden/) || e.match?(/ly\z/) }
=> ["lovely", "2 lonely", "dent"]
</code></pre><p><strong>e)</strong> For the given input string, change whole word <code>mall</code> to <code>1234</code> only if it is at start of line.<pre><code class=language-ruby>'> para = %q{ball fall wall tall
'> mall call ball pall
'> wall mall ball fall
>> mallet wallet malls}

>> puts para.gsub(/^mall\b/, '1234')
ball fall wall tall
1234 call ball pall
wall mall ball fall
mallet wallet malls
</code></pre><p><strong>f)</strong> For the given array, filter all elements having a line starting with <code>den</code> or ending with <code>ly</code>.<pre><code class=language-ruby>>> items = ['lovely', "1\ndentist", '2 lonely', 'eden', "fly\nfar", 'dent']

>> items.filter { |e| e.match?(/^den/) || e.match?(/ly$/) }
=> ["lovely", "1\ndentist", "2 lonely", "fly\nfar", "dent"]
</code></pre><p><strong>g)</strong> For the given input array, filter all whole elements <code>12\nthree</code> irrespective of case.<pre><code class=language-ruby>>> items = ["12\nthree\n", "12\nThree", "12\nthree\n4", "12\nthree"]

>> items.grep(/\A12\nthree\z/i)
=> ["12\nThree", "12\nthree"]
</code></pre><p><strong>h)</strong> For the given input array, replace <code>hand</code> with <code>X</code> for all words that start with <code>hand</code> followed by at least one word character.<pre><code class=language-ruby>>> items = %w[handed hand handy unhanded handle hand-2]

>> items.map { |e| e.sub(/\bhand\B/, 'X') }
=> ["Xed", "hand", "Xy", "unhanded", "Xle", "hand-2"]
</code></pre><p><strong>i)</strong> For the given input array, filter all elements starting with <code>h</code>. Additionally, replace <code>e</code> with <code>X</code> for these filtered elements.<pre><code class=language-ruby>>> items = %w[handed hand handy unhanded handle hand-2]

>> items.filter_map { |e| e.gsub(/e/, 'X') if e.match?(/\Ah/) }
=> ["handXd", "hand", "handy", "handlX", "hand-2"]
</code></pre><br><h1><a class=header href=#alternation-and-grouping id=alternation-and-grouping>Alternation and Grouping</a></h1><p><strong>a)</strong> For the given input array, filter all elements that start with <code>den</code> or end with <code>ly</code><pre><code class=language-ruby>>> items = ['lovely', "1\ndentist", '2 lonely', 'eden', "fly\n", 'dent']

>> items.grep(/\Aden|ly\z/)
=> ["lovely", "2 lonely", "dent"]
</code></pre><p><strong>b)</strong> For the given array, filter all elements having a line starting with <code>den</code> or ending with <code>ly</code><pre><code class=language-ruby>>> items = ['lovely', "1\ndentist", '2 lonely', 'eden', "fly\nfar", 'dent']

>> items.grep(/^den|ly$/)
=> ["lovely", "1\ndentist", "2 lonely", "fly\nfar", "dent"]
</code></pre><p><strong>c)</strong> For the given input strings, replace all occurrences of <code>removed</code> or <code>reed</code> or <code>received</code> or <code>refused</code> with <code>X</code>.<pre><code class=language-ruby>>> s1 = 'creed refuse removed read'
>> s2 = 'refused reed redo received'

>> pat = /re(mov|ceiv|fus|)ed/

>> s1.gsub(pat, 'X')
=> "cX refuse X read"
>> s2.gsub(pat, 'X')
=> "X X redo X"
</code></pre><p><strong>d)</strong> For the given input strings, replace all matches from the array <code>words</code> with <code>A</code>.<pre><code class=language-ruby>>> s1 = 'plate full of slate'
>> s2 = "slated for later, don't be late"
>> words = %w[late later slated]

>> pat = Regexp.union(words.sort_by { |w| -w.length })

>> s1.gsub(pat, 'A')
=> "pA full of sA"
>> s2.gsub(pat, 'A')
=> "A for A, don't be A"
</code></pre><p><strong>e)</strong> Filter all whole elements from the input array <code>items</code> that exactly matches any of the elements present in the array <code>words</code>.<pre><code class=language-ruby>>> items = ['slate', 'later', 'plate', 'late', 'slates', 'slated ']
>> words = %w[late later slated]

>> pat = Regexp.union(words.sort_by { |w| -w.length })
>> pat = /\A(#{pat.source})\z/

>> items.grep(pat)
=> ["later", "late"]
</code></pre><br><h1><a class=header href=#escaping-metacharacters id=escaping-metacharacters>Escaping metacharacters</a></h1><p><strong>a)</strong> Transform given input strings to expected output using same logic on both strings.<pre><code class=language-ruby>>> str1 = '(9-2)*5+qty/3'
>> str2 = '(qty+4)/2-(9-2)*5+pq/4'

>> str1.gsub('(9-2)*5', '35')
=> "35+qty/3"
>> str2.gsub('(9-2)*5', '35')
=> "(qty+4)/2-35+pq/4"
</code></pre><p><strong>b)</strong> Replace <code>(4)\|</code> with <code>2</code> only at the start or end of given input strings.<pre><code class=language-ruby>>> s1 = '2.3/(4)\|6 foo 5.3-(4)\|'
>> s2 = '(4)\|42 - (4)\|3'
>> s3 = "two - (4)\\|\n"

>> pat = /\A\(4\)\\\||\(4\)\\\|\z/

>> s1.gsub(pat, '2')
=> "2.3/(4)\\|6 foo 5.3-2"
>> s2.gsub(pat, '2')
=> "242 - (4)\\|3"
>> s3.gsub(pat, '2')
=> "two - (4)\\|\n"
</code></pre><p><strong>c)</strong> Replace any matching item from given array with <code>X</code> for given input strings. Match the elements from <code>items</code> literally. Assume no two elements of <code>items</code> will result in any matching conflict.<pre><code class=language-ruby>>> items = ['a.b', '3+n', 'x\y\z', 'qty||price', '{n}']

>> pat = Regexp.union(items)

>> '0a.bcd'.gsub(pat, 'X')
=> "0Xcd"
>> 'E{n}AMPLE'.gsub(pat, 'X')
=> "EXAMPLE"
>> '43+n2 ax\y\ze'.gsub(pat, 'X')
=> "4X2 aXe"
</code></pre><p><strong>d)</strong> Replace backspace character <code>\b</code> with a single space character for the given input string.<pre><code class=language-ruby>>> ip = "123\b456"
>> puts ip
12456

>> ip.gsub(/\x08/, ' ')
=> "123 456"
</code></pre><p><strong>e)</strong> Replace all occurrences of <code>\o</code> with <code>o</code>.<pre><code class=language-ruby>>> ip = 'there are c\omm\on aspects am\ong the alternati\ons'

>> ip.gsub(/\\o/, 'o')
=> "there are common aspects among the alternations"
</code></pre><p><strong>f)</strong> Replace any matching item from the array <code>eqns</code> with <code>X</code> for given the string <code>ip</code>. Match the items from <code>eqns</code> literally.<pre><code class=language-ruby>>> ip = '3-(a^b)+2*(a^b)-(a/b)+3'
>> eqns = %w[(a^b) (a/b) (a^b)+2]

>> pat = Regexp.union(eqns.sort_by { |w| -w.length })

>> ip.gsub(pat, 'X')
=> "3-X*X-X+3"
</code></pre><br><h1><a class=header href=#dot-metacharacter-and-quantifiers id=dot-metacharacter-and-quantifiers>Dot metacharacter and Quantifiers</a></h1><blockquote><p><img src=images/info.svg alt=info> Since <code>.</code> metacharacter doesn't match newline character by default, assume that the input strings in the following exercises will not contain newline characters.</blockquote><p><strong>a)</strong> Replace <code>42//5</code> or <code>42/5</code> with <code>8</code> for the given input.<pre><code class=language-ruby>>> ip = 'a+42//5-c pressure*3+42/5-14256'

>> ip.gsub(%r{42//?5}, '8')
=> "a+8-c pressure*3+8-14256"
</code></pre><p><strong>b)</strong> For the array <code>items</code>, filter all elements starting with <code>hand</code> and ending with at most one more character or <code>le</code>.<pre><code class=language-ruby>>> items = %w[handed hand handled handy unhand hands handle]

>> items.grep(/\Ahand(.|le)?\z/)
=> ["hand", "handy", "hands", "handle"]
</code></pre><p><strong>c)</strong> Use <code>split</code> method to get the output as shown for the given input strings.<pre><code class=language-ruby>>> eqn1 = 'a+42//5-c'
>> eqn2 = 'pressure*3+42/5-14256'
>> eqn3 = 'r*42-5/3+42///5-42/53+a'

>> pat = %r{42//?5}

>> eqn1.split(pat)
=> ["a+", "-c"]
>> eqn2.split(pat)
=> ["pressure*3+", "-14256"]
>> eqn3.split(pat)
=> ["r*42-5/3+42///5-", "3+a"]
</code></pre><p><strong>d)</strong> For the given input strings, remove everything from the first occurrence of <code>i</code> till end of the string.<pre><code class=language-ruby>>> s1 = 'remove the special meaning of such constructs'
>> s2 = 'characters while constructing'

>> pat = /i.*/

>> s1.sub(pat, '')
=> "remove the spec"
>> s2.sub(pat, '')
=> "characters wh"
</code></pre><p><strong>e)</strong> For the given strings, construct a regexp to get output as shown.<pre><code class=language-ruby>>> str1 = 'a+b(addition)'
>> str2 = 'a/b(division) + c%d(#modulo)'
>> str3 = 'Hi there(greeting). Nice day(a(b)'

>> remove_parentheses = /\(.*?\)/

>> str1.gsub(remove_parentheses, '')
=> "a+b"
>> str2.gsub(remove_parentheses, '')
=> "a/b + c%d"
>> str3.gsub(remove_parentheses, '')
=> "Hi there. Nice day"
</code></pre><p><strong>f)</strong> Correct the given regexp to get the expected output.<pre><code class=language-ruby>>> words = 'plink incoming tint winter in caution sentient'

# wrong output
>> change = /int|in|ion|ing|inco|inter|ink/
>> words.gsub(change, 'X')
=> "plXk XcomXg tX wXer X cautX sentient"

# expected output
>> change = /in(ter|co|t|g|k)?|ion/
>> words.gsub(change, 'X')
=> "plX XmX tX wX X cautX sentient"
</code></pre><p><strong>g)</strong> For the given greedy quantifiers, what would be the equivalent form using <code>{m,n}</code> representation?<ul><li><code>?</code> is same as <code>{,1}</code><li><code>*</code> is same as <code>{0,}</code><li><code>+</code> is same as <code>{1,}</code></ul><p><strong>h)</strong> <code>(a*|b*)</code> is same as <code>(a|b)*</code> — true or false?<p>False. Because <code>(a*|b*)</code> will match only sequences like <code>a</code>, <code>aaa</code>, <code>bb</code>, <code>bbbbbbbb</code>. But <code>(a|b)*</code> can match a mixed sequence like <code>ababbba</code> too.<p><strong>i)</strong> For the given input strings, remove everything from the first occurrence of <code>test</code> (irrespective of case) till end of the string, provided <code>test</code> isn't at the end of the string.<pre><code class=language-ruby>>> s1 = 'this is a Test'
>> s2 = 'always test your RE for corner cases'
>> s3 = 'a TEST of skill tests?'

>> pat = /test.+/i

>> s1.sub(pat, '')
=> "this is a Test"
>> s2.sub(pat, '')
=> "always "
>> s3.sub(pat, '')
=> "a "
</code></pre><p><strong>j)</strong> For the input array <code>words</code>, filter all elements starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.<pre><code class=language-ruby>>> words = %w[sequoia subtle exhibit asset sets tests site]

>> words.grep(/\As.*(e.*t|t.*e)/)
=> ["subtle", "sets", "site"]
</code></pre><p><strong>k)</strong> For the input array <code>words</code>, remove all elements having less than <code>6</code> characters.<pre><code class=language-ruby>>> words = %w[sequoia subtle exhibit asset sets tests site]

>> words.grep(/.{6,}/)
=> ["sequoia", "subtle", "exhibit"]
</code></pre><p><strong>l)</strong> For the input array <code>words</code>, filter all elements starting with <code>s</code> or <code>t</code> and having a maximum of <code>6</code> characters.<pre><code class=language-ruby>>> words = %w[sequoia subtle exhibit asset sets tests site]

>> words.grep(/\A(s|t).{,5}\z/)
=> ["subtle", "sets", "tests", "site"]
</code></pre><p><strong>m)</strong> Can you reason out why this code results in the output shown? The aim was to remove all <code>&LTcharacters></code> patterns but not the <code><></code> ones. The expected result was <code>'a 1<> b 2<> c'</code>.<p>The use of <code>.+</code> quantifier after <code><</code> means that <code><></code> cannot be a possible match to satisfy <code><.+?></code>. So, after matching <code><</code> (which occurs after <code>1</code> and <code>2</code> in the given input string) the regular expression engine will look for next occurrence of <code>></code> character to satisfy the given pattern. To solve such cases, you need to use character classes, which is discussed in a later chapter, to specify which particular set of characters should be matched by the <code>+</code> quantifier instead of <code>.</code> metacharacter.<pre><code class=language-ruby>>> ip = 'a&LTapple> 1<> b&LTbye> 2<> c&LTcat>'

>> ip.gsub(/<.+?>/, '')
=> "a 1 2"
</code></pre><p><strong>n)</strong> Use <code>split</code> method to get the output as shown below for given input strings.<pre><code class=language-ruby>>> s1 = 'go there  ::   this :: that'
>> s2 = 'a::b :: c::d e::f :: 4::5'
>> s3 = '42:: hi::bye::see :: carefully'

>> pat = / +:: +/

>> s1.split(pat, 2)
=> ["go there", "this :: that"]
>> s2.split(pat, 2)
=> ["a::b", "c::d e::f :: 4::5"]
>> s3.split(pat, 2)
=> ["42:: hi::bye::see", "carefully"]
</code></pre><p><strong>o)</strong> For the given input strings, match if the string starts with optional space characters followed by at least two <code>#</code> characters.<pre><code class=language-ruby>>> s1 = '   ## header2'
>> s2 = '#### header4'
>> s3 = '# comment'
>> s4 = 'normal string'
>> s5 = 'nope ## not this'

>> pat = /\A *\#{2,}/

>> s1.match?(pat)
=> true
>> s2.match?(pat)
=> true
>> s3.match?(pat)
=> false
>> s4.match?(pat)
=> false
>> s5.match?(pat)
=> false
</code></pre><br><h1><a class=header href=#working-with-matched-portions id=working-with-matched-portions>Working with matched portions</a></h1><p><strong>a)</strong> For the given strings, extract the matching portion from first <code>is</code> to last <code>t</code>.<pre><code class=language-ruby>>> str1 = 'This the biggest fruit you have seen?'
>> str2 = 'Your mission is to read and practice consistently'

>> pat = /is.*t/

>> str1[pat]
=> "is the biggest fruit"
>> str2[pat]
=> "ission is to read and practice consistent"
</code></pre><p><strong>b)</strong> Find the starting index of first occurrence of <code>is</code> or <code>the</code> or <code>was</code> or <code>to</code> for the given input strings.<pre><code class=language-ruby>>> s1 = 'match after the last newline character'
>> s2 = 'and then you want to test'
>> s3 = 'this is good bye then'
>> s4 = 'who was there to see?'

>> pat = /is|the|was|to/

>> s1 =~ pat
=> 12
>> s2 =~ pat
=> 4
>> s3 =~ pat
=> 2
>> s4 =~ pat
=> 4
</code></pre><p><strong>c)</strong> Find the starting index of last occurrence of <code>is</code> or <code>the</code> or <code>was</code> or <code>to</code> for the given input strings.<pre><code class=language-ruby>>> s1 = 'match after the last newline character'
>> s2 = 'and then you want to test'
>> s3 = 'this is good bye then'
>> s4 = 'who was there to see?'

>> pat = /.*(is|the|was|to)/

>> s1.match(pat).begin(1)
=> 12
>> s2.match(pat).begin(1)
=> 18
>> s3.match(pat).begin(1)
=> 17
>> s4.match(pat).begin(1)
=> 14
</code></pre><p><strong>d)</strong> The given input string contains <code>:</code> exactly once. Extract all characters after the <code>:</code> as output.<pre><code class=language-ruby>>> ip = 'fruits:apple, mango, guava, blueberry'

# can also use: ip[/:(.*)/, 1]
>> ip.match(/:(.*)/)[1]
'apple, mango, guava, blueberry'
</code></pre><p><strong>e)</strong> The given input strings contains some text followed by <code>-</code> followed by a number. Replace that number with its <code>log</code> value using <code>Math.log()</code>.<pre><code class=language-ruby>>> s1 = 'first-3.14'
>> s2 = 'next-123'

>> pat = /-(.+)/

>> s1.sub(pat) { "-#{Math.log($1.to_f)}" }
=> "first-1.144222799920162"
>> s2.sub(pat) { "-#{Math.log($1.to_f)}" }
=> "next-4.812184355372417"
</code></pre><p><strong>f)</strong> Replace all occurrences of <code>par</code> with <code>spar</code>, <code>spare</code> with <code>extra</code> and <code>park</code> with <code>garden</code> for the given input strings.<pre><code class=language-ruby>>> str1 = 'apartment has a park'
>> str2 = 'do you have a spare cable'
>> str3 = 'write a parser'

>> pat = /park?|spare/
>> h = { 'par' => 'spar', 'spare' => 'extra', 'park' => 'garden' }

>> str1.gsub(pat, h)
=> "aspartment has a garden"
>> str2.gsub(pat, h)
=> "do you have a extra cable"
>> str3.gsub(pat, h)
=> "write a sparser"
</code></pre><p><strong>g)</strong> Extract all words between <code>(</code> and <code>)</code> from the given input string as an array. Assume that the input will not contain any broken parentheses.<pre><code class=language-ruby>>> ip = 'another (way) to reuse (portion) matched (by) capture groups'

# as nested array output
>> ip.scan(/\((.*?)\)/)
=> [["way"], ["portion"], ["by"]]

# as array of strings output
>> ip.gsub(/\((.*?)\)/).map { $1 }
=> ["way", "portion", "by"]
</code></pre><p><strong>h)</strong> Extract all occurrences of <code><</code> up to next occurrence of <code>></code>, provided there is at least one character in between <code><</code> and <code>></code>.<pre><code class=language-ruby>>> ip = 'a&LTapple> 1<> b&LTbye> 2<> c&LTcat>'

>> ip.scan(/<.+?>/)
=> ["&LTapple>", "<> b&LTbye>", "<> c&LTcat>"]
</code></pre><p><strong>i)</strong> Use <code>scan</code> to get the output as shown below for the given input strings. Note the characters used in the input strings carefully.<pre><code class=language-ruby>>> row1 = '-2,5 4,+3 +42,-53 4356246,-357532354 '
>> row2 = '1.32,-3.14 634,5.63 63.3e3,9907809345343.235 '

>> pat = /(.+?),(.+?) /

>> row1.scan(pat)
=> [["-2", "5"], ["4", "+3"], ["+42", "-53"], ["4356246", "-357532354"]]
>> row2.scan(pat)
=> [["1.32", "-3.14"], ["634", "5.63"], ["63.3e3", "9907809345343.235"]]
</code></pre><p><strong>j)</strong> This is an extension to the previous question.<ul><li>For <code>row1</code>, find the sum of integers of each array element. For example, sum of <code>-2</code> and <code>5</code> is <code>3</code>.<li>For <code>row2</code>, find the sum of floating-point numbers of each array element. For example, sum of <code>1.32</code> and <code>-3.14</code> is <code>-1.82</code>.</ul><pre><code class=language-ruby>>> row1 = '-2,5 4,+3 +42,-53 4356246,-357532354 '
>> row2 = '1.32,-3.14 634,5.63 63.3e3,9907809345343.235 '

# should be same as previous question
>> pat = /(.+?),(.+?) /

>> row1.scan(pat).map { |a, b| a.to_i + b.to_i }
=> [3, 7, -11, -353176108]

>> row2.scan(pat).map { |a, b| a.to_f + b.to_f }
=> [-1.82, 639.63, 9907809408643.234]
</code></pre><p><strong>k)</strong> Use <code>split</code> method to get the output as shown below.<pre><code class=language-ruby>>> ip = '42:no-output;1000:car-truck;SQEX49801'

>> ip.split(/:.+?-(.+?);/)
=> ["42", "output", "1000", "truck", "SQEX49801"]
</code></pre><p><strong>l)</strong> Convert the comma separated strings to corresponding <code>hash</code> objects as shown below. Note that the input strings have an extra <code>,</code> at the end.<pre><code class=language-ruby>>> row1 = 'name:rohan,maths:75,phy:89,'
>> row2 = 'name:rose,maths:88,phy:92,'

>> pat = /(.+?):(.+?),/

>> row1.scan(pat).to_h
=> {"name"=>"rohan", "maths"=>"75", "phy"=>"89"}
>> row2.scan(pat).to_h
=> {"name"=>"rose", "maths"=>"88", "phy"=>"92"}
</code></pre><br><h1><a class=header href=#character-class id=character-class>Character class</a></h1><p><strong>a)</strong> For the array <code>items</code>, filter all elements starting with <code>hand</code> and ending with <code>s</code> or <code>y</code> or <code>le</code>.<pre><code class=language-ruby>>> items = %w[-handy hand handy unhand hands handle]

>> items.grep(/\Ahand([sy]|le)\z/)
=> ["handy", "hands", "handle"]
</code></pre><p><strong>b)</strong> Replace all whole words <code>reed</code> or <code>read</code> or <code>red</code> with <code>X</code>.<pre><code class=language-ruby>>> ip = 'redo red credible :read: rod reed'

>> ip.gsub(/\bre[ae]?d\b/, 'X')
=> "redo X credible :X: rod X"
</code></pre><p><strong>c)</strong> For the array <code>words</code>, filter all elements containing <code>e</code> or <code>i</code> followed by <code>l</code> or <code>n</code>. Note that the order mentioned should be followed.<pre><code class=language-ruby>>> words = %w[surrender unicorn newer door empty eel pest]

>> words.grep(/[ei].*[ln]/)
=> ["surrender", "unicorn", "eel"]
</code></pre><p><strong>d)</strong> For the array <code>words</code>, filter all elements containing <code>e</code> or <code>i</code> and <code>l</code> or <code>n</code> in any order.<pre><code class=language-ruby>>> words = %w[surrender unicorn newer door empty eel pest]

>> words.grep(/[ei].*[ln]|[ln].*[ei]/)
=> ["surrender", "unicorn", "newer", "eel"]
</code></pre><p><strong>e)</strong> Convert the comma separated strings to corresponding <code>hash</code> objects as shown below.<pre><code class=language-ruby>>> row1 = 'name:rohan,maths:75,phy:89'
>> row2 = 'name:rose,maths:88,phy:92'

>> pat = /([^:]+):([^,]+),?/

>> row1.scan(pat).to_h
=> {"name"=>"rohan", "maths"=>"75", "phy"=>"89"}
>> row2.scan(pat).to_h
=> {"name"=>"rose", "maths"=>"88", "phy"=>"92"}
</code></pre><p><strong>f)</strong> Delete from <code>(</code> to the next occurrence of <code>)</code> unless they contain parentheses characters in between.<pre><code class=language-ruby>>> str1 = 'def factorial()'
>> str2 = 'a/b(division) + c%d(#modulo) - (e+(j/k-3)*4)'
>> str3 = 'Hi there(greeting). Nice day(a(b)'

>> remove_parentheses = /\([^()]*\)/

>> str1.gsub(remove_parentheses, '')
=> "def factorial"
>> str2.gsub(remove_parentheses, '')
=> "a/b + c%d - (e+*4)"
>> str3.gsub(remove_parentheses, '')
=> "Hi there. Nice day(a"
</code></pre><p><strong>g)</strong> For the array <code>words</code>, filter all elements not starting with <code>e</code> or <code>p</code> or <code>u</code>.<pre><code class=language-ruby>>> words = %w[surrender unicorn newer door empty eel pest]

>> words.grep(/\A[^epu]/)
=> ["surrender", "newer", "door"]
</code></pre><p><strong>h)</strong> For the array <code>words</code>, filter all elements not containing <code>u</code> or <code>w</code> or <code>ee</code> or <code>-</code>.<pre><code class=language-ruby>>> words = %w[p-t you tea heel owe new reed ear]

>> words.grep_v(/[uw-]|ee/)
=> ["tea", "ear"]
</code></pre><p><strong>i)</strong> The given input strings contain fields separated by <code>,</code> and fields can be empty too. Replace last three fields with <code>WHTSZ323</code>.<pre><code class=language-ruby>>> row1 = '(2),kite,12,,D,C,,'
>> row2 = 'hi,bye,sun,moon'

>> pat = /(,[^,]*){3}\z/

>> row1.sub(pat, ',WHTSZ323')
=> "(2),kite,12,,D,WHTSZ323"
>> row2.sub(pat, ',WHTSZ323')
=> "hi,WHTSZ323"
</code></pre><p><strong>j)</strong> Split the given strings based on consecutive sequence of digit or whitespace characters.<pre><code class=language-ruby>>> str1 = "lion \t Ink32onion Nice"
>> str2 = "**1\f2\n3star\t7 77\r**"

>> pat = /[\d\s]+/

>> str1.split(pat)
=> ["lion", "Ink", "onion", "Nice"]
>> str2.split(pat)
=> ["**", "star", "**"]
</code></pre><p><strong>k)</strong> Delete all occurrences of the sequence <code>&LTcharacters></code> where <code>characters</code> is one or more non <code>></code> characters and cannot be empty.<pre><code class=language-ruby>>> ip = 'a&LTapple> 1<> b&LTbye> 2<> c&LTcat>'

>> ip.gsub(/<[^>]+>/, '')
=> "a 1<> b 2<> c"
</code></pre><p><strong>l)</strong> <code>\b[a-z](on|no)[a-z]\b</code> is same as <code>\b[a-z][on]{2}[a-z]\b</code>. True or False? Sample input lines shown below might help to understand the differences, if any.<p>False. <code>[on]{2}</code> will also match <code>oo</code> and <code>nn</code>.<pre><code class=language-ruby>>> puts "known\nmood\nknow\npony\ninns"
known
mood
know
pony
inns
</code></pre><p><strong>m)</strong> For the given array, filter all elements containing any number sequence greater than <code>624</code>.<pre><code class=language-ruby>>> items = ['h0000432ab', 'car00625', '42_624 0512', '96 foo1234baz 3.14 2']

>> items.filter { |e| e.gsub(/\d+/).any? { $&.to_i > 624 } }
=> ["car00625", "96 foo1234baz 3.14 2"]
</code></pre><p><strong>n)</strong> Count the maximum depth of nested braces for the given strings. Unbalanced or wrongly ordered braces should return <code>-1</code>. Note that this will require a mix of regular expressions and Ruby code.<pre><code class=language-ruby>?> def max_nested_braces(ip)
?>   cnt = 0
?>   cnt += 1 while ip.gsub!(/\{[^{}]*\}/, '')
?>   return ip.match?(/[{}]/) ? -1 : cnt
>> end

>> max_nested_braces('a*b')
=> 0
>> max_nested_braces('}a+b{')
=> -1
>> max_nested_braces('a*b+{}')
=> 1
>> max_nested_braces('{{a+2}*{b+c}+e}')
=> 2
>> max_nested_braces('{{a+2}*{b+{c*d}}+e}')
=> 3
>> max_nested_braces("{{a+2}*{\n{b+{c*d}}+e*d}}")
=> 4
>> max_nested_braces('a*{b+c*{e*3.14}}}')
=> -1
</code></pre><p><strong>o)</strong> By default, <code>split</code> method will split on whitespace and remove empty strings from the result. Which regexp based method would you use to replicate this functionality?<pre><code class=language-ruby>>> ip = " \t\r  so  pole\t\t\t\n\nlit in to \r\n\v\f  "

>> ip.split
=> ["so", "pole", "lit", "in", "to"]

>> ip.scan(/\S+/)
=> ["so", "pole", "lit", "in", "to"]
</code></pre><p><strong>p)</strong> Convert the given input string to two different arrays as shown below. You can optimize the regexp based on characters present in the input string.<pre><code class=language-ruby>>> ip = "price_42 roast^\t\n^-ice==cat\neast"

>> ip.split(/\W+/)
=> ["price_42", "roast", "ice", "cat", "east"]

>> ip.split(/(\W+)/)
=> ["price_42", " ", "roast", "^\t\n^-", "ice", "==", "cat", "\n", "east"]
</code></pre><p><strong>q)</strong> Filter all elements whose first non-whitespace character is not a <code>#</code> character. Any element made up of only whitespace characters should be ignored as well.<pre><code class=language-ruby>>> items = ['    #comment', "\t\napple #42", '#oops', 'sure', 'no#1', "\t\r\f"]

# can also use: items.grep(/\A\s*[^#\s]/)
>> items.grep(/\A\s*+[^#]/)
=> ["\t\napple #42", "sure", "no#1"]
</code></pre><p><strong>r)</strong> Extract all whole words for the given input strings. However, based on user input <code>ignore</code>, do not match words if they contain any character present in the <code>ignore</code> variable. Assume that <code>ignore</code> variable will not contain any regexp metacharacter.<pre><code class=language-ruby>>> s1 = 'match after the last newline character'
>> s2 = 'and then you want to test'

>> ignore = 'aty'
>> pat = /\b[\w&&[^#{ignore}]]+\b/
>> s1.scan(pat)
=> ["newline"]
>> s2.scan(pat)
=> []

>> ignore = 'esw'
>> pat = /\b[\w&&[^#{ignore}]]+\b/
>> s1.scan(pat)
=> ["match"]
>> s2.scan(pat)
=> ["and", "you", "to"]
</code></pre><br><h1><a class=header href=#groupings-and-backreferences id=groupings-and-backreferences>Groupings and backreferences</a></h1><p><strong>a)</strong> Replace the space character that occurs after a word ending with <code>a</code> or <code>r</code> with a newline character.<pre><code class=language-ruby>>> ip = 'area not a _a2_ roar took 22'

>> puts ip.gsub(/([ar]) /, "\\1\n")
area
not a
_a2_ roar
took 22
</code></pre><p><strong>b)</strong> Add <code>[]</code> around words starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.<pre><code class=language-ruby>>> ip = 'sequoia subtle exhibit asset sets tests site'

>> ip.gsub(/\bs\w*(t\w*e|e\w*t)\w*/, '[\0]')
=> "sequoia [subtle] exhibit asset [sets] tests [site]"
</code></pre><p><strong>c)</strong> Replace all whole words with <code>X</code> that start and end with the same word character. Single character word should get replaced with <code>X</code> too, as it satisfies the stated condition.<pre><code class=language-ruby>>> ip = 'oreo not a _a2_ roar took 22'

>> ip.gsub(/\b(\w|(\w)\w*\2)\b/, 'X')
=> "X not X X X took X"
</code></pre><p><strong>d)</strong> Convert the given <strong>markdown</strong> headers to corresponding <strong>anchor</strong> tag. Consider the input to start with one or more <code>#</code> characters followed by space and word characters. The <code>name</code> attribute is constructed by converting the header to lowercase and replacing spaces with hyphens. Can you do it without using a capture group?<pre><code class=language-ruby>>> header1 = '# Regular Expressions'
>> header2 = '## Named capture groups'

>> anchor = /\w.*/

>> header1.sub(anchor) { "&LTa name='#{$&.downcase.tr(' ', '-')}'>&LT/a>#{$&}" }
=> "# &LTa name='regular-expressions'>&LT/a>Regular Expressions"
>> header2.sub(anchor) { "&LTa name='#{$&.downcase.tr(' ', '-')}'>&LT/a>#{$&}" }
=> "## &LTa name='named-capture-groups'>&LT/a>Named capture groups"
</code></pre><p><strong>e)</strong> Convert the given <strong>markdown</strong> anchors to corresponding <strong>hyperlinks</strong>.<pre><code class=language-ruby>>> anchor1 = "# &LTa name='regular-expressions'>&LT/a>Regular Expressions"
>> anchor2 = "## &LTa name='subexpression-calls'>&LT/a>Subexpression calls"

>> hyperlink = %r{[^']+'([^']+)'>&LT/a>(.+)}

>> anchor1.sub(hyperlink, '[\2](#\1)')
=> "[Regular Expressions](#regular-expressions)"
>> anchor2.sub(hyperlink, '[\2](#\1)')
=> "[Subexpression calls](#subexpression-calls)"
</code></pre><p><strong>f)</strong> Count the number of whole words that have at least two occurrences of consecutive repeated alphabets. For example, words like <code>stillness</code> and <code>Committee</code> should be counted but not words like <code>root</code> or <code>readable</code> or <code>rotational</code>.<pre><code class=language-ruby>'> ip = %q{oppressed abandon accommodation bloodless
'> carelessness committed apparition innkeeper
'> occasionally afforded embarrassment foolishness
'> depended successfully succeeded
>> possession cleanliness suppress}

>> ip.scan(/\b(\w*(\w)\2){2}\w*\b/).size
=> 13
</code></pre><p><strong>g)</strong> For the given input string, replace all occurrences of digit sequences with only the unique non-repeating sequence. For example, <code>232323</code> should be changed to <code>23</code> and <code>897897</code> should be changed to <code>897</code>. If there no repeats (for example <code>1234</code>) or if the repeats end prematurely (for example <code>12121</code>), it should not be changed.<pre><code class=language-ruby>>> ip = '1234 2323 453545354535 9339 11 60260260'

>> ip.gsub(/\b(\d+)\1+\b/, '\1')
=> "1234 23 4535 9339 1 60260260"
</code></pre><p><strong>h)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the first word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-ruby>>> ip = 'wow:Good:2_two:five: hi-2 bye kite.777.water.'

>> ip.gsub(/(\w+)[:.](\w+[:.])+/, '\1')
=> "wow hi-2 bye kite"
</code></pre><p><strong>i)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the last word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-ruby>>> ip = 'wow:Good:2_two:five: hi-2 bye kite.777.water.'

>> ip.gsub(/((\w+)[:.])+/, '\2')
=> "five hi-2 bye water"
</code></pre><p><strong>j)</strong> Split the given input string on one or more repeated sequence of <code>cat</code>.<pre><code class=language-ruby>>> ip = 'firecatlioncatcatcatbearcatcatparrot'

>> ip.split(/(?:cat)+/)
=> ["fire", "lion", "bear", "parrot"]
</code></pre><p><strong>k)</strong> For the given input string, find all occurrences of digit sequences with at least one repeating sequence. For example, <code>232323</code> and <code>897897</code>. If the repeats end prematurely, for example <code>12121</code>, it should not be matched.<pre><code class=language-ruby>>> ip = '1234 2323 453545354535 9339 11 60260260'

>> pat = /\b(\d+)\1+\b/

# entire sequences in the output
>> ip.gsub(pat).map { $& }
=> ["2323", "453545354535", "11"]

# only the unique sequence in the output
>> ip.gsub(pat).map { $1 }
=> ["23", "4535", "1"]
</code></pre><p><strong>l)</strong> Convert the comma separated strings to corresponding <code>hash</code> objects as shown below. The keys are <code>name</code>, <code>maths</code> and <code>phy</code> for the three fields in the input strings.<pre><code class=language-ruby>>> row1 = 'rohan,75,89'
>> row2 = 'rose,88,92'

>> pat = /(?&LTname>[^,]+),(?&LTmaths>[^,]+),(?&LTphy>[^,]+)/

>> row1.match(pat).named_captures
=> {"name"=>"rohan", "maths"=>"75", "phy"=>"89"}
>> row2.match(pat).named_captures
=> {"name"=>"rose", "maths"=>"88", "phy"=>"92"}
</code></pre><p><strong>m)</strong> Surround all whole words with <code>()</code>. Additionally, if the whole word is <code>imp</code> or <code>ant</code>, delete them. Can you do it with single substitution?<pre><code class=language-ruby>>> ip = 'tiger imp goat eagle ant important'

>> ip.gsub(/\b(?:imp|ant|(\w+))\b/, '(\1)')
=> "(tiger) () (goat) (eagle) () (important)"
</code></pre><p><strong>n)</strong> Filter all elements that contains a sequence of lowercase alphabets followed by <code>-</code> followed by digits. They can be optionally surrounded by <code>{{</code> and <code>}}</code>. Any partial match shouldn't be part of the output.<pre><code class=language-ruby>>> ip = %w[{{apple-150}} {{mango2-100}} {{cherry-200 grape-87 {{go-to}}]

>> ip.grep(/\A({{)?[a-z]+-\d+(?(1)}})\z/)
=> ["{{apple-150}}", "grape-87"]
</code></pre><p><strong>o)</strong> Extract all hex character sequences, with <code>0x</code> optional prefix. Match the characters case insensitively, and the sequences shouldn't be surrounded by other word characters.<pre><code class=language-ruby>>> str1 = '128A foo 0xfe32 34 0xbar'
>> str2 = '0XDEADBEEF place 0x0ff1ce bad'

>> hex_seq = /\b(?:0x)?\h+\b/i

>> str1.scan(hex_seq)
=> ["128A", "0xfe32", "34"]
>> str2.scan(hex_seq)
=> ["0XDEADBEEF", "0x0ff1ce", "bad"]
</code></pre><p><strong>p)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the first/last word of the sequence and the separator. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-ruby>>> ip = 'wow:Good:2_two:five: hi-2 bye kite.777.water.'

# first word of the sequence
>> ip.gsub(/((\w+[:.]))\g&LT2>+/, '\1')
=> "wow: hi-2 bye kite."

# last word of the sequence
>> ip.gsub(/(\w+[:.])\g&LT1>+/, '\1')
=> "five: hi-2 bye water."
</code></pre><p><strong>q)</strong> For the given input strings, extract <code>if</code> followed by any number of nested parentheses. Assume that there will be only one such pattern per input string.<pre><code class=language-ruby>>> ip1 = 'for (((i*3)+2)/6) if(3-(k*3+4)/12-(r+2/3)) while()'
>> ip2 = 'if+while if(a(b)c(d(e(f)1)2)3) for(i=1)'

>> pat = /if(\((?:[^()]++|\g&LT1>)++\))/

>> ip1[pat]
=> "if(3-(k*3+4)/12-(r+2/3))"
>> ip2[pat]
=> "if(a(b)c(d(e(f)1)2)3)"
</code></pre><br><h1><a class=header href=#lookarounds id=lookarounds>Lookarounds</a></h1><blockquote><p><img src=images/info.svg alt=info> Please use lookarounds for solving the following exercises even if you can do it without lookarounds. Unless you cannot use lookarounds for cases like variable length lookbehinds.</blockquote><p><strong>a)</strong> Replace all whole words with <code>X</code> unless it is preceded by <code>(</code> character.<pre><code class=language-ruby>>> ip = '(apple) guava berry) apple (mango) (grape'

>> ip.gsub(/(?&LT!\()\b\w+/, 'X')
=> "(apple) X X) X (mango) (grape"
</code></pre><p><strong>b)</strong> Replace all whole words with <code>X</code> unless it is followed by <code>)</code> character.<pre><code class=language-ruby>>> ip = '(apple) guava berry) apple (mango) (grape'

>> ip.gsub(/\b\w+\b(?!\))/, 'X')
=> "(apple) X berry) X (mango) (X"
</code></pre><p><strong>c)</strong> Replace all whole words with <code>X</code> unless it is preceded by <code>(</code> or followed by <code>)</code> characters.<pre><code class=language-ruby>>> ip = '(apple) guava berry) apple (mango) (grape'

>> ip.gsub(/(?&LT!\()\b\w+\b(?!\))/, 'X')
=> "(apple) X berry) X (mango) (grape"
</code></pre><p><strong>d)</strong> Extract all whole words that do not end with <code>e</code> or <code>n</code>.<pre><code class=language-ruby>>> ip = 'at row on urn e note dust n'

>> ip.scan(/\b\w+\b(?&LT![en])/)
=> ["at", "row", "dust"]
</code></pre><p><strong>e)</strong> Extract all whole words that do not start with <code>a</code> or <code>d</code> or <code>n</code>.<pre><code class=language-ruby>>> ip = 'at row on urn e note dust n'

>> ip.scan(/(?![adn])\b\w+\b/)
=> ["row", "on", "urn", "e"]
</code></pre><p><strong>f)</strong> Extract all whole words only if they are followed by <code>:</code> or <code>,</code> or <code>-</code>.<pre><code class=language-ruby>>> ip = 'poke,on=-=so:ink.to/is(vast)ever-sit'

>> ip.scan(/\w+(?=[:,-])/)
=> ["poke", "so", "ever"]
</code></pre><p><strong>g)</strong> Extract all whole words only if they are preceded by <code>=</code> or <code>/</code> or <code>-</code>.<pre><code class=language-ruby>>> ip = 'poke,on=-=so:ink.to/is(vast)ever-sit'

# can also use: ip.scan(%r{[=/-]\K\w+})
>> ip.scan(%r{(?<=[=/-])\w+})
=> ["so", "is", "sit"]
</code></pre><p><strong>h)</strong> Extract all whole words only if they are preceded by <code>=</code> or <code>:</code> and followed by <code>:</code> or <code>.</code>.<pre><code class=language-ruby>>> ip = 'poke,on=-=so:ink.to/is(vast)ever-sit'

# can also use: ip.scan(/[=:]\K\w+(?=[:.])/)
>> ip.scan(/(?<=[=:])\w+(?=[:.])/)
=> ["so", "ink"]
</code></pre><p><strong>i)</strong> Extract all whole words only if they are preceded by <code>=</code> or <code>:</code> or <code>.</code> or <code>(</code> or <code>-</code> and not followed by <code>.</code> or <code>/</code>.<pre><code class=language-ruby>>> ip = 'poke,on=-=so:ink.to/is(vast)ever-sit'

# can also use: ip.scan(%r{[=:.(-]\K\w+\b(?![/.])})
>> ip.scan(%r{(?<=[=:.(-])\w+\b(?![/.])})
=> ["so", "vast", "sit"]
</code></pre><p><strong>j)</strong> Remove leading and trailing whitespaces from all the individual fields where <code>,</code> is the field separator.<pre><code class=language-ruby>>> csv1 = " comma  ,separated ,values \t\r "
>> csv2 = 'good bad,nice  ice  , 42 , ,   stall   small'

>> remove_whitespace = /(?&LT![^,])\s+|\s+(?![^,])/

>> csv1.gsub(remove_whitespace, '')
=> "comma,separated,values"
>> csv2.gsub(remove_whitespace, '')
=> "good bad,nice  ice,42,,stall   small"
</code></pre><p><strong>k)</strong> Filter all elements that satisfy all of these rules:<ul><li>should have at least two alphabets<li>should have at least 3 digits<li>should have at least one special character among <code>%</code> or <code>*</code> or <code>#</code> or <code>$</code><li>should not end with a whitespace character</ul><pre><code class=language-ruby>>> pwds = ['hunter2', 'F2H3u%9', "*X3Yz3.14\t", 'r2_d2_42', 'A $B C1234']

>> rule_chk = /(?=(.*[a-zA-Z]){2})(?=(.*\d){3})(?!.*\s\z).*[%*#$]/

>> pwds.grep(rule_chk)
=> ["F2H3u%9", "A $B C1234"]
</code></pre><p><strong>l)</strong> For the given string, surround all whole words with <code>{}</code> except for whole words <code>par</code> and <code>cat</code> and <code>apple</code>.<pre><code class=language-ruby>>> ip = 'part; cat {super} rest_42 par scatter apple spar'

>> ip.gsub(/\b(?!(?:par|cat|apple)\b)\w+\b/, '{\0}')
=> "{part}; cat {{super}} {rest_42} par {scatter} apple {spar}"
</code></pre><p><strong>m)</strong> Extract integer portion of floating-point numbers for the given string. A number ending with <code>.</code> and no further digits should not be considered.<pre><code class=language-ruby>>> ip = '12 ab32.4 go 5 2. 46.42 5'

>> ip.scan(/\d+(?=\.\d+)/)
=> ["32", "46"]
</code></pre><p><strong>n)</strong> For the given input strings, extract all overlapping two character sequences.<pre><code class=language-ruby>>> s1 = 'apple'
>> s2 = '1.2-3:4'

>> pat = /.(?=(.))/

>> s1.gsub(pat).map { $& + $1 }
=> ["ap", "pp", "pl", "le"]
>> s2.gsub(pat).map { $& + $1 }
=> ["1.", ".2", "2-", "-3", "3:", ":4"]
</code></pre><p><strong>o)</strong> The given input strings contain fields separated by <code>:</code> character. Delete <code>:</code> and the last field if there is a digit character anywhere before the last field.<pre><code class=language-ruby>>> s1 = '42:cat'
>> s2 = 'twelve:a2b'
>> s3 = 'we:be:he:0:a:b:bother'

>> pat = /(\d.*):.*/

>> s1.sub(pat, '\1')
=> "42"
>> s2.sub(pat, '\1')
=> "twelve:a2b"
>> s3.sub(pat, '\1')
=> "we:be:he:0:a:b"
</code></pre><p><strong>p)</strong> Extract all whole words unless they are preceded by <code>:</code> or <code><=></code> or <code>----</code> or <code>#</code>.<pre><code class=language-ruby>>> ip = '::very--at<=>row|in.a_b#b2c=>lion----east'

>> ip.scan(/(?&LT![:#]|<=>|-{4})\b\w+/)
=> ["at", "in", "a_b", "lion"]
</code></pre><p><strong>q)</strong> Match strings if it contains <code>qty</code> followed by <code>price</code> but not if there is <strong>whitespace</strong> or the string <code>error</code> between them.<pre><code class=language-ruby>>> str1 = '23,qty,price,42'
>> str2 = 'qty price,oh'
>> str3 = '3.14,qty,6,errors,9,price,3'
>> str4 = "42\nqty-6,apple-56,price-234,error"
>> str5 = '4,price,3.14,qty,4'

# can also use: neg = /qty((?!\s|error).)*price/
>> neg = /qty(?~\s|error)price/

>> str1.match?(neg)
=> true
>> str2.match?(neg)
=> false
>> str3.match?(neg)
=> false
>> str4.match?(neg)
=> true
>> str5.match?(neg)
=> false
</code></pre><p><strong>r)</strong> Can you reason out why the output shown is different for these two regular expressions?<p><code>\b</code> matches both the start and end of word locations. In the below example, <code>\b..\b</code> doesn't necessarily mean that first <code>\b</code> will match only the start of word location and second <code>\b</code> will match only the end of word location. They can be any combination! For example, <code>I</code> followed by space in the input string here is using start of word location for both whereas space followed by <code>2</code> is using end of word location for both.<p>In contrast, the negative lookarounds only ensure that there are no word characters around any two characters. And these assertions will always be satisfied at the start of string and the end of string respectively. But <code>\b</code> depends on the presence of word characters. So, <code>!</code> at the end of the input string here matches the lookaround assertion but not word boundary.<pre><code class=language-ruby>>> ip = 'I have 12, he has 2!'

>> ip.gsub(/\b..\b/, '{\0}')
=> "{I }have {12}{, }{he} has{ 2}!"

>> ip.gsub(/(?&LT!\w)..(?!\w)/, '{\0}')
=> "I have {12}, {he} has {2!}"
</code></pre><p><strong>s)</strong> The given input string has fields separated by <code>:</code> character. Delete all fields, including the separator, unless the field contains a digit character. Stop deleting once a field with digit character is found.<pre><code class=language-ruby>>> row1 = 'vast:a2b2:ride:in:awe:b2b:3list:end'
>> row2 = 'um:no:low:3e:s4w:seer'
>> row3 = 'thr33:f0ur'

>> pat = /\G[^\d:]+:/

>> row1.gsub(pat, '')
=> "a2b2:ride:in:awe:b2b:3list:end"
>> row2.gsub(pat, '')
=> "3e:s4w:seer"
>> row3.gsub(pat, '')
=> "thr33:f0ur"
</code></pre><br><h1><a class=header href=#modifiers id=modifiers>Modifiers</a></h1><p><strong>a)</strong> Remove from first occurrence of <code>hat</code> to last occurrence of <code>ice</code> for the given input strings. Match these markers case insensitively.<pre><code class=language-ruby>>> s1 = "But Cool THAT\nsee What okay\nwow quite"
>> s2 = 'it this hat is sliced HIT.'

>> pat = /hat.*it/im

>> s1.sub(pat, '')
=> "But Cool Te"
>> s2.sub(pat, '')
=> "it this ."
</code></pre><p><strong>b)</strong> Delete from the string <code>start</code> if it is at the beginning of a line up to the next occurrence of the string <code>end</code> at the end of a line. Match these keywords irrespective of case.<pre><code class=language-ruby>'> para = %q{good start
'> start working on that
'> project you always wanted
'> to, do not let it end
'> hi there
'> start and end the end
'> 42
'> Start and try to
'> finish the End
>> bye}

>> pat = /^start.*?end$/im

>> puts para.gsub(pat, '')
good start

hi there

42

bye
</code></pre><p><strong>c)</strong> For the given <strong>markdown</strong> file, replace all occurrences of the string <code>ruby</code> (irrespective of case) with the string <code>Ruby</code>. However, any match within code blocks that start with whole line <code>```ruby</code> and end with whole line <code>```</code> shouldn't be replaced. Consider the input file to be small enough to fit memory requirements.<p>Refer to <a href=https://github.com/learnbyexample/Ruby_Regexp/tree/master/exercises>exercises folder</a> for input files required to solve the exercises.<pre><code class=language-ruby>>> ip_str = File.open('sample.md').read
>> pat = /(^```ruby$.*?^```$)/m

>> File.open('sample_mod.md', 'w') do |f|
?>   ip_str.split(pat).each_with_index do |s, i|
?>     f.write(i.odd? ? s : s.gsub(/ruby/i) { $&.capitalize })
>>   end
>> end

>> File.open('sample_mod.md').read == File.open('expected.md').read
=> true
</code></pre><p><strong>d)</strong> Write a string method that changes given input to alternate case (starting with lowercase first).<pre><code class=language-ruby>?> def aLtErNaTe_CaSe(ip_str)
?>   b = true
?>   return ip_str.gsub(/[a-z]/i) { (b = !b) ? $&.upcase : $&.downcase }
>> end

>> aLtErNaTe_CaSe('HI THERE!')
=> "hI tHeRe!"
>> aLtErNaTe_CaSe('good morning')
=> "gOoD mOrNiNg"
>> aLtErNaTe_CaSe('Sample123string42with777numbers')
=> "sAmPlE123sTrInG42wItH777nUmBeRs"
</code></pre><p><strong>e)</strong> For the given input strings, match all of these three patterns:<ul><li><code>This</code> case sensitively<li><code>nice</code> and <code>cool</code> case insensitively</ul><pre><code class=language-ruby>>> s1 = 'This is nice and Cool'
>> s2 = 'Nice and cool this is'
>> s3 = 'What is so nice and cool about This?'

>> pat = /(?=.*nice)(?=.*cool)(?-i:.*This)/i

>> s1.match?(pat)
=> true
>> s2.match?(pat)
=> false
>> s3.match?(pat)
=> true
</code></pre><p><strong>f)</strong> For the given input strings, match if the string begins with <code>Th</code> and also contains a line that starts with <code>There</code>.<pre><code class=language-ruby>>> s1 = "There there\nHave a cookie"
>> s2 = "This is a mess\nYeah?\nThereeeee"
>> s3 = "Oh\nThere goes the fun"

>> pat = /\A(?=Th)(?m:.*^There)/

>> s1.match?(pat)
=> true
>> s2.match?(pat)
=> true
>> s3.match?(pat)
=> false
</code></pre><br><h1><a class=header href=#unicode id=unicode>Unicode</a></h1><p><strong>a)</strong> Output <code>true</code> or <code>false</code> depending on input string made up of ASCII characters or not. Consider the input to be non-empty strings and any character that isn't part of 7-bit ASCII set should give <code>false</code><pre><code class=language-ruby>>> str1 = '123—456'
>> str2 = 'good fοοd'
>> str3 = 'happy learning!'

# can also use ! str1.match?(/[^\u{00}-\u{7f}]/)
>> str1.ascii_only?
=> false
>> str2.ascii_only?
=> false
>> str3.ascii_only?
=> true
</code></pre><p><strong>b)</strong> Retain only punctuation characters for the given strings (generated from codepoints). Use Unicode character set definition for punctuation for solving this exercise.<pre><code class=language-ruby>>> s1 = (0..0x7f).to_a.pack('U*')
>> s2 = (0x80..0xff).to_a.pack('U*')
>> s3 = (0x2600..0x27eb).to_a.pack('U*')

>> pat = /\p{^P}/

>> s1.gsub(pat, '')
=> "!\"#%&'()*,-./:;?@[\\]_{}"
>> s2.gsub(pat, '')
=> "¡§«¶·»¿"
>> s3.gsub(pat, '')
=> "❨❩❪❫❬❭❮❯❰❱❲❳❴❵⟅⟆⟦⟧⟨⟩⟪⟫"
</code></pre><p><strong>c)</strong> Explore the following Q&A threads.<ul><li><a href=https://stackoverflow.com/questions/24672834/how-do-i-remove-emoji-from-string>stackoverflow: remove emoji from string</a><li><a href=https://stackoverflow.com/questions/13573136/why-am-i-seeing-different-results-for-these-two-nearly-identical-ruby-regex-patt>stackoverflow: why am I seeing different results for these two nearly identical regexp</a><li><a href=https://stackoverflow.com/questions/37338708/convert-unicode-number-to-integer-in-ruby>stackoverflow: convert unicode number to integer</a><li><a href=https://stackoverflow.com/questions/28773392/replacing-uxxxx-to-the-corresponding-unicode-codepoint-in-ruby>stackoverflow: replacing %uXXXX to the corresponding unicode codepoint</a></ul></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=further-reading.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=further-reading.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>